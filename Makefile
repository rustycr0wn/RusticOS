# Makefile for rusticOS - bootloader, loader, and 32-bit kernel

.PHONY: all clean distclean run run-debug

# Tools
NASM := nasm
DD := dd
QEMU := qemu-system-x86_64
CC := gcc
CXX := g++
LD := ld
OBJCOPY := objcopy

# Directories
BOOT_DIR := boot
SRC_DIR := src
BUILD_DIR := build

# Compiler flags for 32-bit kernel
CFLAGS := -m32 -ffreestanding -fno-pic -fno-pie -fno-stack-protector -O2
CXXFLAGS := -m32 -ffreestanding -fno-pic -fno-pie -fno-stack-protector -O2 -fno-exceptions -fno-rtti
ASFLAGS := -m32
LDFLAGS := -m elf_i386 -static -T linker.ld

# Source files
KERNEL_SOURCES := $(SRC_DIR)/kernel.cpp $(SRC_DIR)/terminal.cpp $(SRC_DIR)/keyboard.cpp \
                  $(SRC_DIR)/command.cpp $(SRC_DIR)/filesystem.cpp $(SRC_DIR)/virtual_disk.cpp \
                  $(SRC_DIR)/cxxabi.cpp
KERNEL_ASM := $(SRC_DIR)/crt0.s
KERNEL_OBJS := $(BUILD_DIR)/crt0.o $(patsubst $(SRC_DIR)/%.cpp,$(BUILD_DIR)/%.o,$(KERNEL_SOURCES))

BOOTLOADER_SRC := $(BOOT_DIR)/bootloader.asm
LOADER_SRC := $(BOOT_DIR)/loader.asm


BOOTLOADER_BIN := $(BUILD_DIR)/bootloader.bin
LOADER_BIN := $(BUILD_DIR)/loader.bin
BOOTLOADER_PADDED := $(BUILD_DIR)/bootloader_padded.bin
LOADER_PADDED := $(BUILD_DIR)/loader_padded.bin
KERNEL_ELF := $(BUILD_DIR)/kernel.elf
KERNEL_BIN := $(BUILD_DIR)/kernel.bin
DISK_IMG := $(BUILD_DIR)/disk.img

# Create build directory
$(BUILD_DIR):
	@mkdir -p $(BUILD_DIR)

# Compile C++ sources to object files
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp | $(BUILD_DIR)
	@echo "Compiling $<..."
	@$(CXX) $(CXXFLAGS) -c $< -o $@

# Assemble crt0.s (AT&T syntax, 32-bit)
$(BUILD_DIR)/crt0.o: $(SRC_DIR)/crt0.s | $(BUILD_DIR)
	@echo "Assembling $<..."
	@as --32 $< -o $@

# Link kernel to an ELF
$(KERNEL_ELF): $(KERNEL_OBJS) | $(BUILD_DIR)
	@echo "Linking kernel (ELF)..."
	@$(LD) $(LDFLAGS) -o $@ $(KERNEL_OBJS)
	@echo "Kernel ELF size: $$(stat -c%s $@) bytes"

# Produce flat binary from the ELF (this is the file used on disk)
$(KERNEL_BIN): $(KERNEL_ELF) | $(BUILD_DIR)
	@echo "Generating flat kernel binary $@..."
	@$(OBJCOPY) -O binary $(KERNEL_ELF) $@
	@echo "Kernel binary size: $$(stat -c%s $@) bytes"

# Generate NASM include with kernel size and sector count
boot/kernel_sectors.inc: $(KERNEL_BIN) | $(BUILD_DIR)
	@echo "Generating $@ from $(KERNEL_BIN)..."
	@size=$$(stat -c%s $(KERNEL_BIN)); \
	sectors=$$(( (size + 511) / 512 )); \
	printf "; Autogenerated by Makefile - do not edit\n" > $@; \
	printf "%%assign KERNEL_SIZE_BYTES %s\n" $$size >> $@; \
	printf "%%assign KERNEL_SECTORS %s\n" $$sectors >> $@

# Generate NASM include with loader size and sector count
boot/loader_sectors.inc: $(LOADER_BIN) | $(BUILD_DIR)
	@echo "Generating $@ from $(LOADER_BIN)..."
	@size=$$(stat -c%s $(LOADER_BIN)); \
	sectors=$$(( (size + 511) / 512 )); \
	printf "; Autogenerated by Makefile - do not edit\n" > $@; \
	printf "%%assign LOADER_SIZE_BYTES %s\n" $$size >> $@; \
	printf "%%assign LOADER_SECTORS %s\n" $$sectors >> $@

# Assemble bootloader (depends on generated loader include)
$(BOOTLOADER_BIN): $(BOOTLOADER_SRC) boot/loader_sectors.inc | $(BUILD_DIR)
	@echo "Assembling bootloader..."
	@$(NASM) -f bin -o $@ $<

# Assemble loader (depends on generated kernel include)

$(LOADER_BIN): $(LOADER_SRC) boot/kernel_sectors.inc | $(BUILD_DIR)
	@echo "Assembling loader..."
	@$(NASM) -f bin -o $@ $<
	@# After assembling loader, patch its DAP LBA placeholder with the actual kernel seek
	@sh -c 'loader_size=$$(stat -c%s "$@"); loader_sectors=$$(( (loader_size + 511) / 512 )); kernel_seek=$$((1 + loader_sectors)); python3 scripts/patch_loader_dap.py "$(LOADER_BIN)" $$kernel_seek || true'

# Pad bootloader to 512 bytes (full sector)
$(BOOTLOADER_PADDED): $(BOOTLOADER_BIN)
	@echo "Padding bootloader to 512 bytes..."
	@$(DD) if=$(BOOTLOADER_BIN) of=$@ bs=512 conv=sync 2>/dev/null

# Pad loader to 512*N bytes (full sectors)
$(LOADER_PADDED): $(LOADER_BIN)
	@echo "Padding loader to full sectors..."
	@$(DD) if=$(LOADER_BIN) of=$@ bs=512 conv=sync 2>/dev/null


# Create disk image with bootloader, loader, and kernel
$(DISK_IMG): $(BOOTLOADER_PADDED) $(LOADER_PADDED) $(KERNEL_BIN) | $(BUILD_DIR)
	@echo "Creating disk image..."
	@$(DD) if=/dev/zero of=$@ bs=512 count=256 2>/dev/null
	@$(DD) if=$(BOOTLOADER_PADDED) of=$@ bs=512 seek=0 conv=notrunc 2>/dev/null
	@$(DD) if=$(LOADER_PADDED) of=$@ bs=512 seek=1 conv=notrunc 2>/dev/null
	@# Compute loader sectors and place kernel after loader
	@loader_size=$$(stat -c%s $(LOADER_BIN)); \
	loader_sectors=$$(( (loader_size + 511) / 512 )); \
	kernel_seek=$$((1 + loader_sectors)); \
	kernel_sectors=$$(( ($(KERNEL_SIZE_BYTES) + 511) / 512 )); \
	kernel_end=$$((kernel_seek + kernel_sectors - 1)); \
	$(DD) if=$(KERNEL_BIN) of=$@ bs=512 seek=$$kernel_seek conv=notrunc 2>/dev/null
	@echo "Disk image created: $@"
	@loader_size=$$(stat -c%s $(LOADER_BIN)); \
	loader_sectors=$$(( (loader_size + 511) / 512 )); \
	kernel_seek=$$((1 + loader_sectors)); \
	kernel_size=$$(stat -c%s $(KERNEL_BIN)); \
	kernel_sectors=$$(( (kernel_size + 511) / 512 )); \
	kernel_end=$$((kernel_seek + kernel_sectors - 1)); \
	printf "  Bootloader:  sector 0 (%d bytes)\n" $$(stat -c%s $(BOOTLOADER_BIN)); \
	printf "  Loader:      sectors 1-%d (%d bytes)\n" $$((kernel_seek - 1)) $$loader_size; \
	printf "  Kernel:      sectors %d-%d (%d bytes)\n" $$kernel_seek $$kernel_end $$kernel_size


# Build all
all: $(DISK_IMG)

# Convenience build targets for iterative development
# Avoid name collision with the `build` directory target; provide `build-all`
.PHONY: build-all kernel loader bootloader image

# Build core artifacts (kernel, loader, bootloader) without creating full disk image
build-all: $(KERNEL_BIN) $(LOADER_BIN) $(BOOTLOADER_BIN)

# Component targets
kernel: $(KERNEL_BIN)

loader: $(LOADER_BIN)

bootloader: $(BOOTLOADER_BIN)

# Alias for the full disk image
image: $(DISK_IMG)

# Run in QEMU with stdio
run: $(DISK_IMG)
	@echo "Running QEMU..."
	@$(QEMU) -drive format=raw,file=$< -m 512M -serial file:/tmp/qemu_serial.log

# Run in QEMU with debugging (no reboot on halt)
run-debug: $(DISK_IMG)
	@echo "Running QEMU (debug mode: -no-reboot)..."
	@$(QEMU) -drive format=raw,file=$<,if=floppy -m 512M -serial stdio -no-reboot

# Run with serial logged to file and no-reboot for debugging
run-test: $(DISK_IMG)
	@echo "Running QEMU (test: serial to file, no-reboot)..."
	@$(QEMU) -drive format=raw,file=$<,if=floppy -m 512M -serial file:$(BUILD_DIR)/serial.log -nographic -no-reboot
	@echo "Serial output logged to $(BUILD_DIR)/serial.log"

# Clean build files
clean:
	@echo "Cleaning build artifacts..."
	@rm -rf $(BUILD_DIR) boot/kernel_sectors.inc boot/loader_sectors.inc
	@rm -f $(KERNEL_ELF)

# Distclean (remove everything)
distclean: clean
	@rm -f $(SRC_DIR)/*.o